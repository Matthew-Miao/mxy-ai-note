# Platform AI User Center 开发规范文档

## 1. 项目概述

本项目采用 **领域驱动设计（DDD）** 架构模式，基于 Spring Boot 框架构建的用户中心微服务。项目严格按照 DDD 分层架构进行组织，确保代码的可维护性、可扩展性和业务内聚性。

### 1.1 架构优化亮点

在传统DDD架构基础上，本项目引入了**校验层（Validator Layer）**和**数据转换层（Converter Layer）**，实现了更清晰的职责分离：

- **校验层**：专门负责入参校验和业务规则校验，采用责任链模式，支持灵活扩展
- **数据转换层**：专门负责不同层次间的数据格式转换，确保数据隔离和格式统一
- **分层解耦**：通过独立的校验层和转换层，彻底解决了校验逻辑和转换逻辑与业务代码耦合的问题

这种设计使得：
1. **业务逻辑更纯粹**：Application层和Domain层专注于业务逻辑，不再混杂校验和转换代码
2. **代码复用性更强**：校验器和转换器可在多个场景中复用
3. **维护成本更低**：校验规则和转换规则集中管理，易于修改和扩展
4. **测试更容易**：各层职责清晰，便于编写单元测试

## 2. 架构分层设计

### 2.1 整体架构层次

```
├── trigger/           # 触发器层（用户接口层）
├── validator/         # 校验层（参数校验）
├── converter/         # 数据转换层（DTO转换）
├── application/       # 应用服务层（编排层）
├── domain/           # 领域层（核心业务逻辑）
├── infrastructure/   # 基础设施层（技术实现）
├── types/            # 通用类型定义
└── config/           # 配置层
```

### 2.2 优化后的分层调用关系

```
Trigger Layer (触发器层)
    ↓
Validator Layer (校验层) ← 新增：入参校验
    ↓
Converter Layer (数据转换层) ← 新增：DTO ↔ Entity 转换
    ↓
Application Layer (应用服务层)
    ↓
Domain Layer (领域层)
    ↓
Converter Layer (数据转换层) ← 新增：Entity ↔ PO 转换
    ↓
Infrastructure Layer (基础设施层)
```

### 2.3 各层职责说明

#### 2.3.1 Trigger 层（触发器层）
- **职责**：处理外部请求，包括 HTTP 接口、RPC 服务、定时任务、消息监听等
- **特点**：只负责接收请求和返回响应，不包含业务逻辑
- **包结构**：
  - `http/controller/` - REST API 控制器
  - `http/dto/` - 数据传输对象
  - `rpc/` - RPC 服务实现
  - `job/` - 定时任务
  - `listener/` - 消息监听器

#### 2.3.2 Validator 层（校验层）
- **职责**：专门负责入参校验，包括基础校验和复杂业务规则校验
- **特点**：
  - 采用责任链模式，支持多级校验
  - 校验逻辑与业务逻辑完全分离
  - 支持自定义校验规则扩展
- **包结构**：
  ```
  validator/
  ├── chain/              # 责任链管理
  ├── rule/               # 校验规则定义
  ├── impl/               # 具体校验器实现
  └── annotation/         # 自定义校验注解
  ```

#### 2.3.3 Converter 层（数据转换层）
- **职责**：负责不同层次间的数据格式转换
- **转换类型**：
  - **DTO ↔ Entity**：触发层与领域层之间的数据转换
  - **Entity ↔ PO**：领域层与基础设施层之间的数据转换
  - **分页对象转换**：PageInfo、PageVO 等分页对象转换
- **包结构**：
  ```
  converter/
  ├── dto/                # DTO转换器
  ├── entity/             # Entity转换器
  ├── page/               # 分页转换器
  └── factory/            # 转换器工厂
  ```

#### 2.3.4 Application 层（应用服务层）
- **职责**：业务流程编排，协调多个领域服务完成复杂业务场景
- **设计模式**：采用接口+实现类的方式进行收敛
- **命名规范**：
  - 接口：`IXxxServiceCase`
  - 实现类：`XxxServiceCaseImpl`
- **特点**：
  - 无状态服务
  - 事务边界控制
  - 跨领域协调
  - 接口收敛，便于测试和扩展

#### 2.3.5 Domain 层（领域层）
- **职责**：核心业务逻辑实现，包含领域模型、领域服务、仓储接口
- **包结构**：
  ```
  domain/
  ├── {业务域}/
  │   ├── model/
  │   │   ├── entity/      # 实体类
  │   │   ├── aggregate/   # 聚合根
  │   │   └── vo/          # 值对象
  │   ├── service/         # 领域服务
  │   ├── adapter/         # 适配器接口
  │   └── package-info.java
  └── shared/              # 共享领域
  ```

#### 2.3.6 Infrastructure 层（基础设施层）
- **职责**：技术实现，包括数据持久化、外部服务调用、缓存等
- **包结构**：
  ```
  infrastructure/
  ├── adapter/
  │   ├── repository/      # 仓储实现
  │   └── sdk/            # 外部服务适配器
  ├── dao/                # 数据访问对象
  │   ├── mapper/         # MyBatis Mapper
  │   └── po/             # 持久化对象
  ├── redis/              # 缓存服务
  └── sdk/                # 第三方 SDK 封装
  ```

## 3. 命名规范

### 3.1 包命名规范
- 基础包名：`com.rongyi.platform.ai.user.center`
- 分层包名：严格按照 DDD 分层结构
- 业务域包名：使用英文单词，如 `payment`、`points`、`order`

### 3.2 类命名规范

| 层次 | 类型 | 命名规范 | 示例 |
|------|------|----------|------|
| Trigger | Controller | `XxxController` | `PointsRechargeOrderController` |
| Trigger | DTO | `XxxRequestDTO`/`XxxResponseDTO` | `CreateOrderRequestDTO` |
| Validator | 校验器接口 | `IXxxValidator` | `ICreateOrderValidator` |
| Validator | 校验器实现 | `XxxValidator` | `CreateOrderValidator` |
| Validator | 校验链管理器 | `XxxValidatorChain` | `OrderValidatorChain` |
| Converter | DTO转换器 | `XxxDtoConverter` | `OrderDtoConverter` |
| Converter | Entity转换器 | `XxxEntityConverter` | `OrderEntityConverter` |
| Converter | 分页转换器 | `XxxPageConverter` | `OrderPageConverter` |
| Application | 应用服务接口 | `IXxxServiceCase` | `IPointsRechargeOrderServiceCase` |
| Application | 应用服务实现 | `XxxServiceCaseImpl` | `PointsRechargeOrderServiceCaseImpl` |
| Domain | 实体 | `XxxEntity` | `PrePaymentEntity` |
| Domain | 聚合根 | `XxxAggregate` | `CompanyAggregate` |
| Domain | 值对象 | `XxxVO` | `PrePaymentRequestVO` |
| Domain | 领域服务接口 | `IXxxService` | `IPaymentService` |
| Domain | 领域服务实现 | `XxxService` | `PaymentService` |
| Domain | 适配器接口 | `IXxxAdapter`/`IXxxRepository` | `IPaymentAdapter` |
| Infrastructure | 仓储实现 | `XxxRepository` | `PaymentRepository` |
| Infrastructure | DAO | `XxxDAO` | `PointsRechargeOrderDAO` |
| Infrastructure | PO | `XxxPO` | `PointsRechargeOrderPO` |
| Infrastructure | Mapper | `XxxMapper` | `PointsRechargeOrderMapper` |

### 3.3 方法命名规范
- 查询方法：`get`、`find`、`query`、`list`
- 新增方法：`create`、`add`、`insert`
- 更新方法：`update`、`modify`
- 删除方法：`delete`、`remove`
- 业务方法：使用业务语义，如 `createOrderAndPrepay`

## 4. 代码注释规范

### 4.1 类注释
```java
/**
 * 类功能描述
 *
 * @author 作者名
 * @date 创建日期
 */
```

### 4.2 方法注释
```java
/**
 * 方法功能描述
 *
 * @param paramName 参数描述
 * @return 返回值描述
 */
```

### 4.3 字段注释
```java
/**
 * 字段描述
 */
private String fieldName;
```

### 4.4 package-info.java 注释
```java
/**
 * 包功能描述
 * 
 * @author 作者名
 * @date 创建日期
 */
package com.rongyi.platform.ai.user.center.domain.payment;
```

## 5. 依赖注入规范

### 5.1 推荐使用方式
```java
@Resource
private IPaymentService paymentService;
```

### 5.2 构造器注入（可选）
```java
public class PaymentController {
    private final IPaymentService paymentService;
    
    public PaymentController(IPaymentService paymentService) {
        this.paymentService = paymentService;
    }
}
```

## 6. 异常处理规范

### 6.1 异常定义
- 使用枚举定义错误码：`ErrorCodeEnums`
- 实现 `IErrorCodeEnum` 接口

```java
public enum ErrorCodeEnums implements IErrorCodeEnum {
    INSUFFICIENT_POINTS("200001", "当前积分余额不足");
    
    private String errorCode;
    private String errorMsg;
    
    // 构造方法和getter方法
}
```

### 6.2 异常处理
- 在应用服务层进行异常捕获和处理
- 使用 `@Transactional(rollbackFor = Exception.class)` 控制事务

## 7. 数据库访问规范

### 7.1 DAO 层规范
- 继承 `ServiceImpl<Mapper, PO>`
- 使用 `@Repository` 注解
- 方法命名体现业务语义

```java
@Repository
@Slf4j
public class PointsRechargeOrderDAO extends ServiceImpl<PointsRechargeOrderMapper, PointsRechargeOrderPO> {
    
    /**
     * 根据公司ID和状态查询充值订单列表
     *
     * @param companyId 公司ID
     * @param status    订单状态
     * @return 充值订单列表
     */
    public List<PointsRechargeOrderPO> findByCompanyIdAndStatus(Long companyId, Integer status) {
        return lambdaQuery()
                .eq(PointsRechargeOrderPO::getCompanyId, companyId)
                .eq(PointsRechargeOrderPO::getStatus, status)
                .eq(PointsRechargeOrderPO::getDeleted, DeletedStatusEnums.UN_DELETED.getValue())
                .list();
    }
}
```

### 7.2 实体映射规范
- PO（Persistent Object）：数据库持久化对象
- Entity：领域实体对象
- VO（Value Object）：值对象
- DTO（Data Transfer Object）：数据传输对象

## 8. 校验层设计规范

### 8.1 校验层架构设计

校验层采用**责任链模式**，支持多级校验和灵活扩展。每个校验器专注于特定的校验逻辑，通过链式调用完成复杂的校验场景。

#### 8.1.1 抽象校验器基类

```java
package com.rongyi.platform.ai.user.center.validator.chain;

import lombok.extern.slf4j.Slf4j;

/**
 * 抽象校验器基类
 * 采用责任链模式，支持多级校验
 *
 * @param <T> 校验对象类型
 * @author lb
 * @date 2025-01-23
 */
@Slf4j
public abstract class AbstractValidator<T> {
    
    /**
     * 下一个校验器
     */
    protected AbstractValidator<T> nextValidator;
    
    /**
     * 设置下一个校验器
     *
     * @param nextValidator 下一个校验器
     * @return 当前校验器
     */
    public AbstractValidator<T> setNext(AbstractValidator<T> nextValidator) {
        this.nextValidator = nextValidator;
        return nextValidator;
    }
    
    /**
     * 执行校验
     *
     * @param target 校验目标对象
     */
    public final void validate(T target) {
        // 执行当前校验器的校验逻辑
        doValidate(target);
        
        // 如果有下一个校验器，继续执行
        if (nextValidator != null) {
            nextValidator.validate(target);
        }
    }
    
    /**
     * 具体的校验逻辑，由子类实现
     *
     * @param target 校验目标对象
     */
    protected abstract void doValidate(T target);
    
    /**
     * 获取校验器名称
     *
     * @return 校验器名称
     */
    protected abstract String getValidatorName();
}
```

#### 8.1.2 校验链管理器

```java
package com.rongyi.platform.ai.user.center.validator.chain;

import org.springframework.stereotype.Component;
import java.util.HashMap;
import java.util.Map;

/**
 * 校验链管理器
 * 负责管理和构建校验链
 *
 * @author lb
 * @date 2025-01-23
 */
@Component
public class ValidatorChainManager {
    
    /**
     * 校验链缓存
     */
    private final Map<Class<?>, AbstractValidator<?>> validatorChainCache = new HashMap<>();
    
    /**
     * 执行校验
     *
     * @param target 校验目标对象
     * @param <T> 对象类型
     */
    @SuppressWarnings("unchecked")
    public <T> void validate(T target) {
        Class<?> targetClass = target.getClass();
        AbstractValidator<T> validatorChain = (AbstractValidator<T>) validatorChainCache.get(targetClass);
        
        if (validatorChain != null) {
            validatorChain.validate(target);
        }
    }
    
    /**
     * 注册校验链
     *
     * @param targetClass 目标类型
     * @param validatorChain 校验链
     * @param <T> 对象类型
     */
    public <T> void registerValidatorChain(Class<T> targetClass, AbstractValidator<T> validatorChain) {
        validatorChainCache.put(targetClass, validatorChain);
    }
}
```

#### 8.1.3 具体校验器实现示例

```java
package com.rongyi.platform.ai.user.center.validator.impl;

import com.rongyi.framework.common.exception.BusinessException;
import com.rongyi.platform.ai.user.center.trigger.http.dto.req.recharge.CreateOrderRequestDTO;
import com.rongyi.platform.ai.user.center.validator.chain.AbstractValidator;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

/**
 * 创建订单请求参数校验器
 *
 * @author lb
 * @date 2025-01-23
 */
@Component
public class CreateOrderValidator extends AbstractValidator<CreateOrderRequestDTO> {
    
    @Override
    protected void doValidate(CreateOrderRequestDTO target) {
        // 基础参数校验
        if (target.getCompanyId() == null || target.getCompanyId() <= 0) {
            throw new BusinessException("公司ID不能为空且必须大于0");
        }
        
        if (target.getProductId() == null || target.getProductId() <= 0) {
            throw new BusinessException("产品ID不能为空且必须大于0");
        }
        
        if (target.getQuantity() == null || target.getQuantity() <= 0) {
            throw new BusinessException("购买数量不能为空且必须大于0");
        }
        
        // 业务规则校验
        if (target.getQuantity() > 1000) {
            throw new BusinessException("单次购买数量不能超过1000");
        }
    }
    
    @Override
    protected String getValidatorName() {
        return "CreateOrderValidator";
    }
}
```

### 8.2 校验层使用规范

#### 8.2.1 在Controller中使用校验层

```java
@RestController
public class PointsRechargeOrderController {
    
    @Resource
    private ValidatorChainManager validatorChainManager;
    
    @Resource
    private IPointsRechargeOrderServiceCase pointsRechargeOrderServiceCase;
    
    /**
     * 创建订单并预支付
     *
     * @param requestDTO 创建订单请求参数
     * @return 创建订单响应
     */
    @PostMapping("/createOrderAndPrepay")
    public ApiResult<CreateOrderResponseDTO> createOrderAndPrepay(
            @RequestBody CreateOrderRequestDTO requestDTO) {
        
        // 1. 校验层处理
        validatorChainManager.validate(requestDTO);
        
        // 2. 调用应用服务层
        CreateOrderResponseDTO response = pointsRechargeOrderServiceCase.createOrderAndPrepay(requestDTO);
        
        return ApiResult.success(response);
    }
}
```

## 9. 数据转换层设计规范

### 9.1 数据转换层架构设计

数据转换层负责不同层次间的数据格式转换，确保各层之间的数据隔离和格式统一。

#### 9.1.1 DTO转换器接口

```java
package com.rongyi.platform.ai.user.center.converter.dto;

/**
 * DTO转换器接口
 * 负责DTO与Entity之间的转换
 *
 * @param <D> DTO类型
 * @param <E> Entity类型
 * @author lb
 * @date 2025-01-23
 */
public interface IDtoConverter<D, E> {
    
    /**
     * DTO转Entity
     *
     * @param dto DTO对象
     * @return Entity对象
     */
    E dtoToEntity(D dto);
    
    /**
     * Entity转DTO
     *
     * @param entity Entity对象
     * @return DTO对象
     */
    D entityToDto(E entity);
}
```

#### 9.1.2 Entity转换器接口

```java
package com.rongyi.platform.ai.user.center.converter.entity;

/**
 * Entity转换器接口
 * 负责Entity与PO之间的转换
 *
 * @param <E> Entity类型
 * @param <P> PO类型
 * @author lb
 * @date 2025-01-23
 */
public interface IEntityConverter<E, P> {
    
    /**
     * Entity转PO
     *
     * @param entity Entity对象
     * @return PO对象
     */
    P entityToPo(E entity);
    
    /**
     * PO转Entity
     *
     * @param po PO对象
     * @return Entity对象
     */
    E poToEntity(P po);
}
```

#### 9.1.3 具体转换器实现示例

```java
package com.rongyi.platform.ai.user.center.converter.dto.impl;

import com.rongyi.platform.ai.user.center.converter.dto.IDtoConverter;
import com.rongyi.platform.ai.user.center.domain.order.model.entity.PointsOrderEntity;
import com.rongyi.platform.ai.user.center.trigger.http.dto.req.recharge.CreateOrderRequestDTO;
import com.rongyi.platform.ai.user.center.types.utils.BeanMapperUtils;
import org.springframework.stereotype.Component;

/**
 * 订单DTO转换器实现
 *
 * @author lb
 * @date 2025-01-23
 */
@Component
public class OrderDtoConverter implements IDtoConverter<CreateOrderRequestDTO, PointsOrderEntity> {
    
    @Override
    public PointsOrderEntity dtoToEntity(CreateOrderRequestDTO dto) {
        if (dto == null) {
            return null;
        }
        
        return PointsOrderEntity.builder()
                .companyId(dto.getCompanyId())
                .productId(dto.getProductId())
                .quantity(dto.getQuantity())
                .customPoints(dto.getCustomPoints())
                .customPrice(dto.getCustomPrice())
                .build();
    }
    
    @Override
    public CreateOrderRequestDTO entityToDto(PointsOrderEntity entity) {
        if (entity == null) {
            return null;
        }
        
        return BeanMapperUtils.map(entity, CreateOrderRequestDTO.class);
    }
}
```

### 9.2 数据转换层使用规范

#### 9.2.1 在Application层使用转换器

```java
@Component
public class PointsRechargeOrderServiceCaseImpl implements IPointsRechargeOrderServiceCase {
    
    @Resource
    private OrderDtoConverter orderDtoConverter;
    
    @Resource
    private IPointsOrderService pointsOrderService;
    
    @Override
    public CreateOrderResponseDTO createOrderAndPrepay(CreateOrderRequestDTO requestDTO) {
        // 1. DTO转Entity
        PointsOrderEntity orderEntity = orderDtoConverter.dtoToEntity(requestDTO);
        
        // 2. 调用领域服务
        PointsOrderEntity createdOrder = pointsOrderService.createOrder(orderEntity);
        
        // 3. Entity转DTO（如果需要）
        return BeanMapperUtils.map(createdOrder, CreateOrderResponseDTO.class);
    }
}
```

## 10. 应用服务层接口设计规范

### 10.1 接口定义规范
- 在 `application` 包下定义应用服务接口
- 使用 `I` 前缀命名，后缀为 `ServiceCase`
- 接口方法体现业务语义，避免技术细节

```java
package com.rongyi.platform.ai.user.center.application;

import com.rongyi.platform.ai.user.center.trigger.http.dto.req.recharge.CreateOrderRequestDTO;
import com.rongyi.platform.ai.user.center.trigger.http.dto.resp.recharge.CreateOrderResponseDTO;

/**
 * 积分充值订单应用服务接口
 * 负责业务流程编排，协调多个领域服务完成复杂业务场景
 *
 * @author mixaoxiaoyu
 * @date 2025-07-28
 */
public interface IPointsRechargeOrderServiceCase {

    /**
     * 创建订单并调用预支付
     *
     * @param requestDTO 创建订单请求参数
     * @return 创建订单响应
     */
    CreateOrderResponseDTO createOrderAndPrepay(CreateOrderRequestDTO requestDTO);

    /**
     * 判断当前公司是否存在待支付的积分充值订单
     *
     * @return 是否存在待支付的积分充值订单
     */
    boolean hasPendingOrder();

}
```

### 10.2 实现类规范
- 在 `application/impl` 包下实现应用服务接口
- 使用 `@Component` 注解标注为Spring组件
- 使用 `@Transactional(rollbackFor = Exception.class)` 控制事务边界
- 通过依赖注入协调多个领域服务

```java
package com.rongyi.platform.ai.user.center.application.impl;

import com.rongyi.platform.ai.user.center.application.IPointsRechargeOrderServiceCase;
import com.rongyi.platform.ai.user.center.domain.order.service.IPointsOrderService;
import com.rongyi.platform.ai.user.center.domain.payment.service.IPaymentService;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

/**
 * 积分充值订单应用服务实现类
 * 负责业务流程编排，协调多个领域服务完成复杂业务场景
 *
 * @author mixaoxiaoyu
 * @date 2025-07-28
 */
@Component
@Slf4j
public class PointsRechargeOrderServiceCaseImpl implements IPointsRechargeOrderServiceCase {

    @Resource
    private IPointsOrderService pointsOrderService;
    @Resource
    private IPaymentService paymentService;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public CreateOrderResponseDTO createOrderAndPrepay(CreateOrderRequestDTO requestDTO) {
        log.info("开始创建订单并预支付，请求参数：{}", requestDTO);
        
        // 1. 创建订单
        PointsOrderEntity orderEntity = pointsOrderService.createOrder(requestDTO);
        
        // 2. 调用预支付
        PrePaymentResponseVO paymentResponse = paymentService.createPrePayment(orderEntity);
        
        // 3. 组装响应
        return CreateOrderResponseDTO.builder()
                .orderId(orderEntity.getId())
                .orderNo(orderEntity.getOrderNo())
                .paymentUrl(paymentResponse.getPaymentUrl())
                .build();
    }

    @Override
    public boolean hasPendingOrder() {
        return pointsOrderService.hasPendingOrderByCompany();
    }
}
```

### 10.3 接口设计原则
1. **单一职责**：每个应用服务接口专注于特定业务域
2. **业务语义**：方法名体现业务含义，而非技术实现
3. **参数封装**：使用DTO对象封装复杂参数
4. **异常处理**：在实现类中处理业务异常
5. **事务控制**：在应用服务层控制事务边界

### 10.4 接口收敛的优势

#### 8.4.1 架构优势
- **解耦合**：接口与实现分离，降低模块间耦合度
- **可测试性**：便于进行单元测试和集成测试
- **可扩展性**：支持多种实现方式，便于功能扩展
- **可维护性**：接口稳定，实现可灵活调整

#### 8.4.2 开发优势
- **并行开发**：接口定义后，多人可并行开发
- **代码复用**：接口可被多个模块复用
- **版本管理**：接口版本化管理，向后兼容
- **文档清晰**：接口即文档，业务逻辑清晰

#### 8.4.3 运维优势
- **监控友好**：便于添加切面进行监控和日志
- **性能优化**：可在接口层添加缓存、限流等功能
- **故障隔离**：接口层可进行熔断、降级处理

### 10.5 Controller层调用规范

在Controller层中，应该直接注入应用服务接口，而不是实现类：

```java
@RestController
@RequestMapping("/api/v1/points/recharge")
@Slf4j
public class PointsRechargeOrderController {

    @Resource
    private IPointsRechargeOrderServiceCase pointsRechargeOrderServiceCase;

    @Operation(summary = "创建新订单并调用预支付接口")
    @PostMapping(value = "createOrderAndPrepay")
    public ApiResult<CreateOrderResponseDTO> createOrderAndPrepay(
            @RequestBody @Valid CreateOrderRequestDTO request) {
        try {
            CreateOrderResponseDTO response = pointsRechargeOrderServiceCase.createOrderAndPrepay(request);
            return ApiResult.success(response);
        } catch (BusinessException e) {
            log.error("创建订单失败：{}", e.getMessage());
            return ApiResult.fail(e.getErrorCode(), e.getErrorMsg());
        }
    }
}
```

## 11. 适配器模式规范

### 11.1 适配器接口定义
- 在 `domain/{业务域}/adapter/` 包下定义接口
- 使用 `I` 前缀命名

```java
package com.rongyi.platform.ai.user.center.domain.payment.adapter;

import com.rongyi.platform.ai.user.center.domain.payment.model.vo.PrePaymentRequestVO;
import com.rongyi.platform.ai.user.center.domain.payment.model.vo.PrePaymentResponseVO;

/**
 * 支付适配器接口
 * 遵循DDD设计原则，领域层通过适配器接口调用基础设施层
 *
 * @author mixaoxiaoyu
 * @date 2025-01-23
 */
public interface IPaymentSdk {

    /**
     * 创建预支付订单
     *
     * @param requestVO 预支付请求参数
     * @return 预支付响应
     */
    PrePaymentResponseVO createPrePayment(PrePaymentRequestVO requestVO);

}
```

### 11.2 适配器在领域服务中的使用
- 在领域服务中注入适配器接口
- 通过适配器调用基础设施层能力

```java
@Service
@Slf4j
public class PaymentService implements IPaymentService {

    @Resource
    private IQrCodeService qrCodeService;
    @Resource
    private IFileUploadService fileUploadService;
    @Resource
    private IPaymentSdk paymentSdk;

    @Override
    public PrePaymentResponseVO createPrePayment(PrePaymentRequestVO requestVO) {
        log.info("开始创建预支付订单，订单号：{}", requestVO.getOrderNo());

        try {
            // 通过适配器调用基础设施层
            PrePaymentResponseVO prePayment = paymentSdk.createPrePayment(requestVO);

            if (!prePayment.getSuccess()) {
                log.error("预支付创建失败，订单号：{}，错误信息：{}", requestVO.getOrderNo(), prePayment.getErrorMessage());
                return PrePaymentResponseVO.builder()
                        .orderNo(requestVO.getOrderNo())
                        .success(false)
                        .errorMessage("预支付创建失败：" + prePayment.getErrorMessage())
                        .build();
            }

            // 生成二维码并上传
            log.info("预支付订单创建成功，订单号：{}，支付链接：{}", requestVO.getOrderNo(), prePayment.getPaymentUrl());
            byte[] qrCode = qrCodeService.generateQrCode(prePayment.getPaymentUrl());
            try (InputStream imageStream = new ByteArrayInputStream(qrCode)) {
                String qrCodeUrl = fileUploadService.uploadInputStream(imageStream, "pay/qrcode", requestVO.getOrderNo() + ".png");
                return PrePaymentResponseVO.builder()
                        .orderNo(requestVO.getOrderNo())
                        .paymentUrl(prePayment.getPaymentUrl())
                        .paymentQrCodeUrl(qrCodeUrl)
                        .success(true)
                        .build();
            }
        } catch (Exception e) {
            log.error("预支付创建异常，订单号：{}", requestVO.getOrderNo(), e);
            return PrePaymentResponseVO.builder()
                    .orderNo(requestVO.getOrderNo())
                    .success(false)
                    .errorMessage("预支付创建异常：" + e.getMessage())
                    .build();
        }
    }
}
```

## 12. 日志规范

### 12.1 日志级别使用
- `log.info()`：关键业务流程日志
- `log.warn()`：警告信息，如降级处理
- `log.error()`：错误信息，需要关注的异常
- `log.debug()`：调试信息

### 12.2 日志格式
```java
log.info("开始创建预支付订单，订单号：{}", orderNo);
log.error("预支付创建失败，订单号：{}，错误信息：{}", orderNo, errorMessage);
```

## 13. 事务管理规范

### 13.1 事务注解使用
```java
@Transactional(rollbackFor = Exception.class)
public CreateOrderResponseDTO createOrderAndPrepay(CreateOrderRequestDTO requestDTO) {
    // 业务逻辑
}
```

### 13.2 事务边界
- **应用服务层**：控制事务边界，使用 `@Transactional` 注解
- **领域服务层**：不控制事务，专注业务逻辑
- **基础设施层**：不控制事务，专注技术实现
- **事务传播**：默认使用 `REQUIRED` 传播行为
- **异常回滚**：统一使用 `rollbackFor = Exception.class`

## 14. 接口设计规范

### 14.1 REST API 规范
- 使用 `@RestController` 注解
- 统一返回 `ApiResult<T>` 格式
- 使用 Swagger 注解进行接口文档

```java
@Operation(summary = "创建新订单并调用预支付接口", description = "一步完成订单创建和预支付，直接返回支付二维码链接")
@PostMapping(value = "createOrderAndPrepay")
public ApiResult<CreateOrderResponseDTO> createOrderAndPrepay(@RequestBody @Valid CreateOrderRequestDTO request) {
    // 实现逻辑
}
```

### 14.2 参数校验
- 使用 `@Valid` 进行参数校验
- 在 DTO 中使用 JSR-303 注解

## 15. 配置管理规范

### 15.1 配置类
- 使用 `@Configuration` 注解
- 配置类放在 `config` 包下

### 15.2 属性配置
- 使用 `@ConfigurationProperties` 绑定配置
- 配置文件使用 YAML 格式

## 16. 测试规范

### 16.1 单元测试
- 测试类命名：`XxxTest`
- 测试方法命名：`testXxx`
- 使用 JUnit 5 和 Mockito

### 16.2 集成测试
- 测试类命名：`XxxIntegrationTest`
- 使用 `@SpringBootTest` 注解

## 17. 代码质量要求

### 17.1 代码风格
- 使用 Lombok 减少样板代码
- 遵循阿里巴巴 Java 开发手册
- 使用 IDE 格式化工具统一代码格式

### 17.2 性能要求
- 避免 N+1 查询问题
- 合理使用缓存
- 异步处理耗时操作

### 17.3 安全要求
- 输入参数校验
- SQL 注入防护
- 敏感信息脱敏

## 16. 版本控制规范

### 16.1 分支管理
- `main`：主分支
- `develop`：开发分支
- `feature/xxx`：功能分支
- `hotfix/xxx`：热修复分支

### 16.2 提交信息
```
feat: 新增支付功能
fix: 修复订单状态更新问题
docs: 更新开发文档
refactor: 重构支付服务
```

## 17. 部署规范

### 17.1 环境配置
- `application-dev.yaml`：开发环境
- `application-test.yaml`：测试环境
- `application-prod.yaml`：生产环境

### 17.2 监控要求
- 接口响应时间监控
- 错误率监控
- 业务指标监控

## 18. 注意事项

1. **分层架构严格遵循**：必须严格按照 Trigger → Validator → Converter → Application → Domain → Infrastructure 的分层调用关系，不允许跨层调用

2. **校验层强制使用**：所有外部输入参数必须经过校验层处理，采用责任链模式进行多级校验，确保数据的完整性和业务规则的正确性

3. **数据转换层规范**：
   - DTO ↔ Entity 转换必须在 Converter 层处理
   - Entity ↔ PO 转换必须在 Infrastructure 层的 Converter 处理
   - 禁止在业务逻辑中直接使用 BeanMapperUtils 进行跨层数据转换

4. **应用服务层接口收敛**：应用服务层必须采用接口+实现类的收敛模式，确保架构的清晰性和可扩展性

5. **Controller层注入规范**：Controller层只能注入校验链管理器、数据转换器和应用服务接口，不能直接注入实现类或领域服务

6. **事务边界控制**：应用服务层负责控制事务边界，使用`@Transactional(rollbackFor = Exception.class)`注解

7. **校验器职责单一**：每个校验器只负责特定的校验逻辑，通过责任链模式组合使用，便于维护和扩展

8. **转换器类型安全**：数据转换器必须保证类型安全，避免运行时类型转换异常

9. **领域层解耦**：领域层不依赖基础设施层，通过适配器模式解耦

10. **代码质量**：保持代码的可读性和可维护性

11. **文档维护**：及时更新文档和注释

12. **持续改进**：定期进行代码审查和重构

---

本规范文档将随着项目发展持续更新和完善。